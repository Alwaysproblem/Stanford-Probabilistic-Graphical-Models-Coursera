[1mdiff --git a/PGM_Programming_Assignment_1/ComputeMarginal.asv b/PGM_Programming_Assignment_1/ComputeMarginal.asv[m
[1mdeleted file mode 100755[m
[1mindex 9254a88..0000000[m
[1m--- a/PGM_Programming_Assignment_1/ComputeMarginal.asv[m
[1m+++ /dev/null[m
[36m@@ -1,37 +0,0 @@[m
[31m-%ComputeMarginal Computes the marginal over a set of given variables[m
[31m-%   M = ComputeMarginal(V, F, E) computes the marginal over variables V[m
[31m-%   in the distribution induced by the set of factors F, given evidence E[m
[31m-%[m
[31m-%   M is a factor containing the marginal over variables V[m
[31m-%   V is a vector containing the variables in the marginal e.g. [1 2 3] for[m
[31m-%     X_1, X_2 and X_3.[m
[31m-%   F is a vector of factors (struct array) containing the factors [m
[31m-%     defining the distribution[m
[31m-%   E is an N-by-2 matrix, each row being a variable/value pair. [m
[31m-%     Variables are in the first column and values are in the second column.[m
[31m-%     If there is no evidence, pass in the empty matrix [] for E.[m
[31m-[m
[31m-[m
[31m-function M = ComputeMarginal(V, F, E)[m
[31m-[m
[31m-% Check for empty factor list[m
[31m-if (numel(F) == 0)[m
[31m-      warning('Warning: empty factor list');[m
[31m-      M = struct('var', [], 'card', [], 'val', []);      [m
[31m-      return;[m
[31m-end[m
[31m-[m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-% YOUR CODE HERE:[m
[31m-% M should be a factor[m
[31m-% Remember to renormalize the entries of M![m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-[m
[31m-M = struct('var', [], 'card', [], 'val', []); % Returns empty factor. Change this.[m
[31m-[m
[31m-F = ObserveEvidence(F, E);[m
[31m-[m
[31m-for i=1:length(V)[m
[31m-[m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-end[m
[1mdiff --git a/PGM_Programming_Assignment_1/FactorMarginalization.asv b/PGM_Programming_Assignment_1/FactorMarginalization.asv[m
[1mdeleted file mode 100755[m
[1mindex 85203e3..0000000[m
[1m--- a/PGM_Programming_Assignment_1/FactorMarginalization.asv[m
[1m+++ /dev/null[m
[36m@@ -1,50 +0,0 @@[m
[31m-% FactorMarginalization Sums given variables out of a factor.[m
[31m-%   B = FactorMarginalization(A,V) computes the factor with the variables[m
[31m-%   in V summed out. The factor data structure has the following fields:[m
[31m-%       .var    Vector of variables in the factor, e.g. [1 2 3][m
[31m-%       .card   Vector of cardinalities corresponding to .var, e.g. [2 2 2][m
[31m-%       .val    Value table of size prod(.card)[m
[31m-%[m
[31m-%   The resultant factor should have at least one variable remaining or this[m
[31m-%   function will throw an error.[m
[31m-% [m
[31m-%   See also FactorProduct.m, IndexToAssignment.m, and AssignmentToIndex.m[m
[31m-[m
[31m-function B = FactorMarginalization(A, V)[m
[31m-[m
[31m-% Check for empty factor or variable list[m
[31m-if (isempty(A.var) || isempty(V)), B = A; return; end;[m
[31m-[m
[31m-% Construct the output factor over A.var \ V (the variables in A.var that are not in V)[m
[31m-% and mapping between variables in A and B[m
[31m-[B.var, mapB] = setdiff(A.var, V);[m
[31m-[m
[31m-% Check for empty resultant factor[m
[31m-if isempty(B.var)[m
[31m-  error('Error: Resultant factor has empty scope');[m
[31m-end;[m
[31m-[m
[31m-% Initialize B.card and B.val[m
[31m-B.card = A.card(mapB);[m
[31m-B.val = zeros(1, prod(B.card));[m
[31m-[m
[31m-% Compute some helper indices[m
[31m-% These will be very useful for calculating B.val[m
[31m-% so make sure you understand what these lines are doing[m
[31m-assignments = IndexToAssignment(1:length(A.val), A.card);[m
[31m-indxB = AssignmentToIndex(assignments(:, mapB), B.card);[m
[31m-[m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-% YOUR CODE HERE[m
[31m-% Correctly populate the factor values of B[m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-[m
[31m-u = unique(indxB);[m
[31m-[m
[31m-for i = u[m
[31m-    inds = idxB == i;[m
[31m-    B.val(i) = sum(A.val(inds));[m
[31m-end;[m
[31m-    [m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-end[m
[1mdiff --git a/PGM_Programming_Assignment_1/FactorProduct.asv b/PGM_Programming_Assignment_1/FactorProduct.asv[m
[1mdeleted file mode 100755[m
[1mindex 0d7f795..0000000[m
[1m--- a/PGM_Programming_Assignment_1/FactorProduct.asv[m
[1m+++ /dev/null[m
[36m@@ -1,69 +0,0 @@[m
[31m-% FactorProduct Computes the product of two factors.[m
[31m-%   C = FactorProduct(A,B) computes the product between two factors, A and B,[m
[31m-%   where each factor is defined over a set of variables with given dimension.[m
[31m-%   The factor data structure has the following fields:[m
[31m-%       .var    Vector of variables in the factor, e.g. [1 2 3][m
[31m-%       .card   Vector of cardinalities corresponding to .var, e.g. [2 2 2][m
[31m-%       .val    Value table of size prod(.card)[m
[31m-%[m
[31m-%   See also FactorMarginalization.m, IndexToAssignment.m, and[m
[31m-%   AssignmentToIndex.m[m
[31m-[m
[31m-function C = FactorProduct(A, B)[m
[31m-[m
[31m-% Check for empty factors[m
[31m-if (isempty(A.var)), C = B; return; end;[m
[31m-if (isempty(B.var)), C = A; return; end;[m
[31m-[m
[31m-% Check that variables in both A and B have the same cardinality[m
[31m-[dummy iA iB] = intersect(A.var, B.var);[m
[31m-if ~isempty(dummy)[m
[31m-	% A and B have at least 1 variable in common[m
[31m-	assert(all(A.card(iA) == B.card(iB)), 'Dimensionality mismatch in factors');[m
[31m-end[m
[31m-[m
[31m-% Set the variables of C[m
[31m-C.var = union(A.var, B.var);[m
[31m-[m
[31m-% Construct the mapping between variables in A and B and variables in C.[m
[31m-% In the code below, we have that[m
[31m-%[m
[31m-%   mapA(i) = j, if and only if, A.var(i) == C.var(j)[m
[31m-% [m
[31m-% and similarly [m
[31m-%[m
[31m-%   mapB(i) = j, if and only if, B.var(i) == C.var(j)[m
[31m-%[m
[31m-% For example, if A.var = [3 1 4], B.var = [4 5], and C.var = [1 3 4 5],[m
[31m-% then, mapA = [2 1 3] and mapB = [3 4]; mapA(1) = 2 because A.var(1) = 3[m
[31m-% and C.var(2) = 3, so A.var(1) == C.var(2).[m
[31m-[m
[31m-[dummy, mapA] = ismember(A.var, C.var);[m
[31m-[dummy, mapB] = ismember(B.var, C.var);[m
[31m-[m
[31m-% Set the cardinality of variables in C[m
[31m-C.card = zeros(1, length(C.var));[m
[31m-C.card(mapA) = A.card;[m
[31m-C.card(mapB) = B.card;[m
[31m-[m
[31m-% Initialize the factor values of C:[m
[31m-%   prod(C.card) is the number of entries in C[m
[31m-C.val = zeros(1, prod(C.card));[m
[31m-[m
[31m-% Compute some helper indices[m
[31m-% These will be very useful for calculating C.val[m
[31m-% so make sure you understand what these lines are doing.[m
[31m-assignments = IndexToAssignment(1:prod(C.card), C.card);[m
[31m-indxA = AssignmentToIndex(assignments(:, mapA), A.card);[m
[31m-indxB = AssignmentToIndex(assignments(:, mapB), B.card);[m
[31m-[m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-% YOUR CODE HERE:[m
[31m-% Correctly populate the factor values of C[m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-[m
[31m-Avals = [m
[31m-[m
[31m-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-[m
[31m-end[m
[1mdiff --git a/PGM_Programming_Assignment_1/ObserveEvidence.asv b/PGM_Programming_Assignment_1/ObserveEvidence.asv[m
[1mdeleted file mode 100755[m
[1mindex 7391c4c..0000000[m
[1m--- a/PGM_Programming_Assignment_1/ObserveEvidence.asv[m
[1m+++ /dev/null[m
[36m@@ -1,56 +0,0 @@[m
[31m-% ObserveEvidence Modify a vector of factors given some evidence.[m
[31m-%   F = ObserveEvidence(F, E) sets all entries in the vector of factors, F,[m
[31m-%   that are not consistent with the evidence, E, to zero. F is a vector of[m
[31m-%   factors, each a data structure with the following fields:[m
[31m-%     .var    Vector of variables in the factor, e.g. [1 2 3][m
[31m-%     .card   Vector of cardinalities corresponding to .var, e.g. [2 2 2][m
[31m-%     .val    Value table of size prod(.card)[m
[31m-%   E is an N-by-2 matrix, where each row consists of a variable/value pair. [m
[31m-%     Variables are in the first column and values are in the second column.[m
[31m-[m
[31m-function F = ObserveEvidence(F, E)[m
[31m-[m
[31m-% Iterate through all evidence[m
[31m-[m
[31m-for i = 1:size(E, 1),[m
[31m-    v = E(i, 1); % variable[m
[31m-    x = E(i, 2); % value[m
[31m-[m
[31m-    % Check validity of evidence[m
[31m-    if (x == 0),[m
[31m-        warning(['Evidence not set for variable ', int2str(v)]);[m
[31m-        continue;[m
[31m-    end;[m
[31m-[m
[31m-    for j = 1:length(F),[m
[31m-		  % Does factor contain variable?[m
[31m-        indx = find(F(j).var == v);[m
[31m-[m
[31m-        if (~isempty(indx)),[m
[31m-        [m
[31m-		  	   % Check validity of evidence[m
[31m-            if (x > F(j).card(indx) || x < 0 ),[m
[31m-                error(['Invalid evidence, X_', int2str(v), ' = ', int2str(x)]);[m
[31m-            end;[m
[31m-[m
[31m-            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-            % YOUR CODE HERE[m
[31m-            % Adjust the factor F(j) to account for observed evidence[m
[31m-            % Hint: You might find it helpful to use IndexToAssignment[m
[31m-            %       and SetValueOfAssignment[m
[31m-            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-            [m
[31m-            assignments = [m
[31m-            [m
[31m-            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[m
[31m-[m
[31m-				% Check validity of evidence / resulting factor[m
[31m-            if (all(F(j).val == 0)),[m
[31m-                warning(['Factor ', int2str(j), ' makes variable assignment impossible']);[m
[31m-            end;[m
[31m-[m
[31m-        end;[m
[31m-    end;[m
[31m-end;[m
[31m-[m
[31m-end[m
